#summary Wicket Web Beans

= Introduction to Wicket Web Beans =

Wicket Web Beans (WWB) is a component toolkit for displaying and editing POJOs that conform to the Java Beans specification. Web pages are automatically generated based on bean properties. The layout, editability, and actions of these pages can be customized on an exception basis. In other words, the toolkit normally does what you'd expect, but when it doesn't, you can override its behavior.

At the highest-level, the BeanForm component provides rich AJAX functionality. Fields within a form are dynamically sent back to the bean as they are changed. This allows for dynamic form updating. Other lower-level components may be used independently of BeanForm and multiple BeanForms may be incorporated on a single page.

= Simple Example = 

Let's take a look at a simple bean from the examples:

{{{
package wicket.contrib.webbeans.examples.simple;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.Serializable;
import java.math.BigDecimal;

public class TestBean implements Serializable 
{
    private static final long serialVersionUID = -8500883418534059147L;

    private String firstName;
    private String lastName;
    private Integer number;
    private BigDecimal operand1;
    private BigDecimal operand2;
    
    private PropertyChangeSupport listeners = new PropertyChangeSupport(this);

    public TestBean()
    {
    }

    /**
     * JavaBeans compliant method to add a PropertyChangeListener. 
     */
    public void addPropertyChangeListener(PropertyChangeListener listener)
    {
        listeners.addPropertyChangeListener(listener);
    }
    
    /**
     * JavaBeans compliant method to remove a PropertyChangeListener. 
     */
    public void removePropertyChangeListener(PropertyChangeListener listener)
    {
        listeners.removePropertyChangeListener(listener);
    }

    public String getFirstName()
    {
        return firstName;
    }

    public void setFirstName(String firstName)
    {
        this.firstName = (firstName == null ? null : firstName.toUpperCase());
    }

    public String getLastName()
    {
        return lastName;
    }

    public void setLastName(String lastName)
    {
        this.lastName = lastName;
    }

    public Integer getNumber()
    {
        return number;
    }

    public void setNumber(Integer number)
    {
        this.number = number;
    }

    public BigDecimal getOperand1()
    {
        return operand1;
    }

    public void setOperand1(BigDecimal operand1)
    {
        this.operand1 = operand1;
        fireResultChange();
    }

    public BigDecimal getOperand2()
    {
        return operand2;
    }

    public void setOperand2(BigDecimal operand2)
    {
        this.operand2 = operand2;
        fireResultChange();
    }

    private void fireResultChange()
    {
        listeners.firePropertyChange("result", null, getResult());
    }
    
    public BigDecimal getResult()
    {
        if (getOperand1() == null || getOperand2() == null) {
            return null;
        }
        
        return getOperand1().add( getOperand2() ); 
    }
}
}}}

This is a Java Bean compliant POJO. As most people know, getters start with "get" or "is" and setters start with "set". Java Beans also require a public no-argument constructor, which we have. This bean also implements PropertyChangeListeners and Events. This is an optional part of the Java Beans spec. However, if you're bean implements add/removerPropertyChangeListener(), BeanForm will automatically register itself as a listener to your bean. In this example, we're going to use PropertyChangeEvents to notify BeanForm when dependent properties change. 

If you don't implement PropertyChangeListeners, BeanForm already knows if a single property changes from a change on the form. For example, setFirstName() automatically changes the input value to upper case. BeanForm knows to refresh this field on the form because the user changed it. If you type "xyzzy" in the First Name field and tab or click away from the field, the field is sent to the bean and the field is dynamically refreshed to it's new value "XYZZY".

Before we get too deep, let's take a look at the Wicket page and HTML:

{{{
<html xmlns:wicket>
<head>
<wicket:head>
    <wicket:link><link href="bean.css" type="text/css" rel="stylesheet" ></link></wicket:link>
	<title>Simple Bean Page</title>
</wicket:head>
</head>
<body >
	<span wicket:id="beanForm"></span>
</body>
</html>
}}}

{{{
package wicket.contrib.webbeans.examples.simple;

import wicket.contrib.webbeans.containers.BeanForm;
import wicket.contrib.webbeans.model.BeanMetaData;
import wicket.markup.html.WebPage;

public class SimpleBeanPage extends WebPage
{
    public SimpleBeanPage()
    {
        TestBean bean = new TestBean();
        BeanMetaData meta = new BeanMetaData(bean.getClass(), null, this, null, false);
        add( new BeanForm("beanForm", bean, meta) );
    }
}
}}}

You can see this is pretty simple. There is only a single component added to the page - "beanForm" - which is an instance of BeanForm. You can see in the constructor that we create an instance of TestBean which is passed to BeanForm. We also create an instance of BeanMetaData. BeanMetaData reflects on the TestBean class to derive the fields for the form.

If you bring up this page in a browser, you will see something like:
||
{{{
Test Bean
----------------------------------------------------------------------------------
First Name        Last Name           Number
[DAN           ]  [Syrstad        ]   [8             ]

Operand 1         Operand 2           Result
[123           ]  [222            ]   333
}}}
||

 Represents the metadata for a bean properties and actions. All beans must be Serializable by Wicket convention.

By default, the metadata originates by convention:

    * Label names for properties are derived from the JavaBean spec "displayName" or from the property name. E.g., "customerName" becomes "Customer Name"; "address2" becomes "Address 2".
    * Field components for the Java primitive/wrapper types, enum types, java.util.Date and those classes deriving from it, and java.util.Lists are pre-configured.
    * All JavaBean properties are displayed.
    * All fields are editable if viewOnly (see constructor) is false. Otherwise they are all view-only.
    * If a property is not writable, it is displayed view-only.
    * All fields are displayed in the order the are reflected.
    * All fields are in a single default group.

The Field types for classes can be specified/overridden in the given ComponentRegistry.

Normally, this class does what you would expect. However, you can override the default conventions by specifying the exceptions in the given Component's ".beanprops" file (see constructor).

If no tabs are specified, a default tab with an id of "DEFAULT_TAB" and a label based on the bean class name. Property-level settings override Bean-level settings.

Certain components that use BeanMetaData listen to PropertyChangeEvents. If your bean implements addPropertyChangeListener/removePropertyChangeListener bean methods, the component can listen for property changes and update components on the page dynamically.

Author:
    Dan Syrstad

= Customizing = 

= Details =

{{{
# Default specification/context for bean TestBean. Package name is optional.
# Standard parameters are: label, actions, props, tabs, displayed, viewOnly.
TestBean {
	# Standard Bean-level parameters are: label, actions, props, tabs, displayed, viewOnly. In addition,
	# you may specify Bean container-specific ones (e.g., BeanGridPanel allows "columns").
	
	# $(property-name) to reference a Wicket property file property (i.e., Localizer). Can be used anywhere in a value and
	# in any kind of value.  Double quotes may be used to embed whitespace in values.
	label: "My ${TestBean.title} Title";   

	# Defines the actions available for the bean.
	# This is a list of action methods available on the Wicket Page that the bean
 	# is embedded in. These methods must be public and have the following signature:
 	#     public void <i>doSomething</i>(AjaxRequestTarget target, Form form, Object bean)
 	# The target parameter may be null for non-Ajax requests. 
 	# These can be referenced as "action.{action-method-name}" in props. 
 	# Actions not included in the "props" parameter are considered to be "global" actions
	# that appear outside of any tabs.
		
	actions: save,cancel,doIt,addRow;

	# This is a list of properties that may have parameters and are presented on the page in the order specified below. 
	# Any other properties not specified are presented at the end of the page. 
	# Properties beginning with "action." refer to actions defined in "actions:" above, not to bean properties.
	# If the property begins with "-", it is not displayed.
	# The "EMPTY" pseudo-property name can be used to provide an empty field (e.g., a blank cell in a grid). 
	# Configuration may be specified for each property within "{}". Standard configuration parameters are:
	#   label, labelImage, viewOnly, fieldType (overrides the Field used), elementType. 
	# For Collections, elementType is the type of the elements
 	# contained within the collection. If this is not specified and the collection is not 
 	# null and not empty, the elementType is detected from the first element of the collection.
	# In addition, you may specify Bean container and Field-level specific parameters (e.g., BeanGridPanel allows "colspan").
	# For action parameters, see BeanActionButton.
	props: 
		action.save{colspan: 3},
		firstName,
		lastName,
		EMPTY,
		activePrimitive,
		color,
		# Note that only the base class name for fieldType is specified, not the package (wicket.contrib.beancomponents.fields) which is optional.
		# This class must be in the ComponentRegistry for this to work. Otherwise, you can explicitly specify the package name. 
		inlineBean{fieldType: BeanInlineField; colspan: 3},
		dateTimestamp,
		blockBean{fieldType: BeanGridField; colspan: 3},
		testBean2{colspan: 3},
		popupBean{colspan: 3},
		-subComponent;  # Explicitly hides subComponent.

	# Tabs are optional. Only specify the properties not on the default tab. 
	# Each tab can define parameters. Standard parameters are: label, props.
	tabs: 
		nameInfo, # Default tab: no props specified, so it gets all of the bean props not used in other tabs.
		miscInfo {
			label: "${MiscInfo.title}";
			props:
				gender,
				EMPTY,  # Empty cell/spacer.
				age,
				operand1,
				operand2,
				result{viewOnly: true},
				# Note that only the base class name for elementType is specified, not the package, which is optional.
				# This class must be in the same package as the bean for this to work. Otherwise, you can explicitly specify the package name. 
				palette{elementType: TestBean$ColorEnum},
				palette2{elementType: TestBean$ColorEnum; viewOnly: true},
				description{fieldType: TextAreaField; rows: 5};
		}, 
		listOfBeans {
			props: 
				action.addRow{colspan: 3}, 
				beans{viewOnly: true; rows: 20};
		};
}

# [] specifies a specific context (e.g., a use-case). This one extends the default context implicitly.
TestBean[view] {
	viewOnly: true;
}

TestBean[popupView extends view] {
	props: 
		-color,		# Remove the color property from the default list. 
		lastName{viewOnly: false}; # Change the parameter of lastName
}

TestBean2 {
	actions: deleteRow;
	props: 
		action.deleteRow{labelImage: "remove.gif"},
		selected{label: X},
		firstName{viewOnly: false},
		lastName;
}
}}}


= CSS Guide =







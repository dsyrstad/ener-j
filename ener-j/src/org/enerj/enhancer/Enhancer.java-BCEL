// Ener-J Enhancer
// Copyright 2001, 2002 Visual Systems Corporation
// $Header: /cvsroot/ener-j/ener-j/src/org/enerj/enhancer/Enhancer.java-BCEL,v 1.3 2005/08/12 02:56:49 dsyrstad Exp $

package org.enerj.enhancer;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Set;

import org.apache.bcel.Constants;
import org.apache.bcel.Repository;
import org.apache.bcel.classfile.Code;
import org.apache.bcel.classfile.ConstantLong;
import org.apache.bcel.classfile.ExceptionTable;
import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.classfile.Synthetic;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.FieldGen;
import org.apache.bcel.generic.FieldInstruction;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFNE;
import org.apache.bcel.generic.IFNONNULL;
import org.apache.bcel.generic.IFNULL;
import org.apache.bcel.generic.IF_ACMPEQ;
import org.apache.bcel.generic.IF_ICMPEQ;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionConstants;
import org.apache.bcel.generic.InstructionFactory;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.InvokeInstruction;
import org.apache.bcel.generic.LDC2_W;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.NOP;
import org.apache.bcel.generic.ObjectType;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.ReferenceType;
import org.apache.bcel.generic.Type;
import org.apache.bcel.util.ClassPath;
import org.apache.bcel.util.SyntheticRepository;
import org.odmg.ODMGException;
import org.enerj.core.ClassVersionSchema;
import org.enerj.core.ClassSchema;
import org.enerj.core.Schema;
import org.enerj.core.SystemCIDMap;
import org.enerj.core.EnerJDatabase;
import org.enerj.core.EnerJImplementation;
import org.enerj.core.EnerJTransaction;
import org.enerj.server.ObjectServer;


/**
 * Ener-J class file enhancer.
 * Try "java .... org.enerj.enhancer.Enhancer --help"
 * for usage information.
 *
 * @version $Id: Enhancer.java-BCEL,v 1.3 2005/08/12 02:56:49 dsyrstad Exp $
 * @author <a href="mailto:dsyrstad@ener-j.org">Dan Syrstad</a>
 */
public class Enhancer 
{
    private static final String FIELD_ACCESSOR_PREFIX = "enerj_Get_";
    private static final String FIELD_MUTATOR_PREFIX = "enerj_Set_";
    private static final String sPersistableHelperClassName = "org.enerj.core.PersistableHelper";
    private static final String sPersistableClassName = "org.enerj.core.Persistable";
    private static final String sPersistentAwareClassName = "org.enerj.core.PersistentAware";
    private static final String sObjectSerializerClassName = "org.enerj.core.ObjectSerializer";
    private static final String sEnerJDatabaseClassName = "org.enerj.core.EnerJDatabase";
    private static final String sDataInputClassName = "java.io.DataInput";
    private static final String sDataOutputClassName = "java.io.DataOutput";
    private static final String sReadContextClassName = sObjectSerializerClassName + "$ReadContext";
    private static final String sWriteContextClassName = sObjectSerializerClassName + "$WriteContext";
    private static final String sPostLoadMethodName = "enerjPostLoad";
    private static final String sPreStoreMethodName = "enerjPreStore";
    private static final String sPostStoreMethodName = "enerjPostStore";
    private static final String sPreHollowMethodName = "enerjPreHollow";
    private static final String sClassIdFieldName = "enerj_sClassId";

    private static final String[] sNoArgNames = new String[0];
    private static final String[] sEnerJDatabaseArgName = new String[] { "aDatabase" };

    private static final ObjectType sPersistableType = new ObjectType(sPersistableClassName);
    private static final ObjectType sDataOutputType = new ObjectType(sDataOutputClassName);
    private static final ObjectType sDataInputType = new ObjectType(sDataInputClassName);
    private static final ObjectType sObjectType = new ObjectType("java.lang.Object");
    private static final ObjectType sEnerJDatabaseType = new ObjectType(sEnerJDatabaseClassName);
    private static final ObjectType sReadContextType = new ObjectType(sReadContextClassName);
    private static final ObjectType sWriteContextType = new ObjectType(sWriteContextClassName);

    private static final Type[] sPersistableArg = new Type[] { sPersistableType };
    private static final Type[] sCheckLoadedArgs = new Type[] { sPersistableType, Type.BOOLEAN };
    private static final Type[] sWriteContextArg = new Type[] { sWriteContextType };
    private static final Type[] sReadContextArg = new Type[] { sReadContextType };
    private static final Type[] sEnerJDatabaseArg = new Type[] { sEnerJDatabaseType };
    private static final Type[] sReadObjectArgs = new Type[] { sReadContextType, sPersistableType };
    private static final Type[] sWriteObjectArgs = new Type[] { sWriteContextType, Type.OBJECT, sPersistableType };
    private static final Type[] sObjectArg = new Type[] { Type.OBJECT };

    private static Exception sLastException = null;
    
    private boolean mDebug = false;
    private MetaData mMetaData;
    private String mSourcePath = System.getProperty("java.class.path", "");
    private String mDestDir = ".";
    private boolean mInPlace = false;
    private String mDatabaseURI = null;
    private EnerJDatabase mDatabase = null;
    private ByteArrayOutputStream mByteStream = null;
    private Schema mSchema = null;

    //----------------------------------------------------------------------
    /**
     * Construct an instance of the Enhancer.
     */
    public Enhancer()
    {
    }

    //----------------------------------------------------------------------
    public static void main(String[] args) throws Exception
    {
        int rc = runEnhancer(args);
        if (rc == 0 || System.getProperty("ANT") == null) {
            System.exit(rc);
        }
        else if (rc != 0) {
            throw new Exception("ANT: Enhancer exiting with return code " + rc);
        }
    }
    
    //----------------------------------------------------------------------
    /**
     * A wrapper for main() so that this can be called without System.exit()
     * being called.
     *
     * @return the exit status, 0 if good, non-zero if bad.
     */
    public static int runEnhancer(String[] args)
    {
        //for (int i = 0; i < args.length; i++) {
        //    System.out.println("args[" + i + "]=" + args[i]);
        //}
        sLastException = null;
        Enhancer enhancer = new Enhancer();

        LinkedList propFiles = new LinkedList();

        // Parse command line arguments.
        for (int i = 0; i < args.length; i++) {
            if (args[i].length() > 0 && args[i].charAt(0) == '-') {  // command line switch
                if (args[i].equals("--sourcepath")) {
                    ++i;
                    if (i >= args.length) {
                        System.err.println("Missing argument to --sourcepath");
                        return 1;
                    }
                    
                    enhancer.mSourcePath = args[i];
                }
                else if (args[i].equals("--destdir")) {
                    ++i;
                    if (i >= args.length) {
                        System.err.println("Missing argument to --destdir");
                        return 1;
                    }
                    
                    enhancer.mDestDir = args[i];
                }
                else if (args[i].equals("--inplace")) {
                    enhancer.mInPlace = true;
                }
                else if (args[i].equals("--database")) {
                    ++i;
                    if (i >= args.length) {
                        System.err.println("Missing argument to --database");
                        return 1;
                    }
                    
                    enhancer.mDatabaseURI = args[i];
                }
                else if (args[i].equals("--debug")) {
                    enhancer.mDebug = true;
                }
                else if (args[i].equals("--help")) {
                    System.out.println("Ener-J Enhancer - Copyright 2001, 2002 Visual Systems Corporation");
                    System.out.println( "Usage: " + Enhancer.class.getName() + " [options] metadata-file...");
                    System.out.println("  --sourcepath path = the classpath-like path where source .class files are found.");
                    System.out.println("      Defaults to the java.class.path system property (the Java classpath).");
                    System.out.println("  --destdir directory = the directory where enhanced classes are written.");
                    System.out.println("      Defaults to the current directory.");
                    System.out.println("  --inplace = enhanced class files are written back to the directory where they were");
                    System.out.println("              originally found. If you specify this option, --destdir is ignored.");
                    System.out.println("  --database = a URI for a Ener-J database (e.g., \"enerj://...\"). Enhanced persistable classes");
                    System.out.println("               are stored in the database schema. Persistence aware classes and");
                    System.out.println("               class id files are written to the directory specified by --destdir or --inplace.");
                    System.out.println("               This argument is only optional when enhancing core system persistables.");
                    System.out.println("  --help = Prints this help text.");
                    System.out.println("  --debug = turns on debugging messages.");
                    System.out.println("");
                    System.out.println("  metadata-file... = one or more Ener-J metadata files.");
                    return 1;
                }
                else {
                    System.err.println("Unknown option " + args[i]);
                    System.err.println("Try --help for options.");
                    return 1;
                }
            }
            else {
                propFiles.add(args[i]);
            }
        }

        if (propFiles.size() == 0) {
          System.err.println("No metadata files specified");
          return 1;
        }
        
        // Override the classpath to use sourcepath. Need to add the boot classpath
        // and java.lang.classpath to get java.lang.Object. Not all VMs may implement
        // sun.boot.class.path, so java.lang.classpath ensures that we find the core
        // classes. The rest of the enhancer code ensures that we only enhance classes
        // in the sourcepath.
        //System.out.println("--> java.lang.classpath=" + System.getProperty("java.class.path"));
        Repository.setRepository( SyntheticRepository.getInstance( 
                        new ClassPath(enhancer.mSourcePath + File.pathSeparatorChar + 
                            System.getProperty("java.class.path") + File.pathSeparatorChar +
                            System.getProperty("sun.boot.class.path") ) ) );

        int returnCode = 0;
        EnerJTransaction txn = null;
        try {
            if (enhancer.mDatabaseURI != null) {
                enhancer.mDatabase = (EnerJDatabase)EnerJImplementation.getInstance().newDatabase();
                enhancer.mDatabase.open(enhancer.mDatabaseURI, EnerJDatabase.OPEN_READ_WRITE);
                txn = (EnerJTransaction)EnerJImplementation.getInstance().newTransaction();

                txn.begin();
                enhancer.mSchema = enhancer.mDatabase.getDatabaseRoot().getSchema();

                // This is used to write the class bytes.
                enhancer.mByteStream = new ByteArrayOutputStream(65536);
            }

            enhancer.mMetaData = new MetaData(propFiles, enhancer.mSourcePath, enhancer.mSchema);
        }
        catch (Exception e) {
            sLastException = e;
            System.err.println("Error parsing metadata:");
            if (e.getClass() == Exception.class) {
                System.err.println(e.getMessage());
            }
            else {
                System.err.println(e.toString());
            }
            
            if (enhancer.mDebug) {
                e.printStackTrace();
            }
            
            returnCode = 1;
        }
        catch (Throwable t) {
            t.printStackTrace();
            returnCode = 1;
        }

        if (returnCode == 0) {
            try {
                enhancer.enhanceClasses();

                if (enhancer.mDatabase != null) {
                    txn.commit();
                    enhancer.mDatabase.close();
                    enhancer.mDatabase = null;
                }
            }
            catch (Exception e) {
                sLastException = e;
                System.err.println("Error while enhancing: ");
                if (e.getClass() == Exception.class) {
                    System.err.println(e.getMessage());
                }
                else {
                    System.err.println(e.toString());
                }

                if (enhancer.mDebug) {
                    e.printStackTrace();
                }

                returnCode = 1;
            }
            catch (Throwable t) {
                t.printStackTrace();
                returnCode = 1;
            }
        }
        
        if (enhancer.mDatabase != null) {
            if (txn != null && txn.isOpen()) {
                txn.abort();
            }

            try {
                if (enhancer.mDatabase.isOpen()) {
                    enhancer.mDatabase.close();
                }
            }
            catch (ODMGException e) { 
                // shouldn't happen - oh well.
                e.printStackTrace();
            }

            enhancer.mDatabase = null;
        }

        Repository.clearCache();
        return returnCode;
    }

    //----------------------------------------------------------------------
    /**
     * Get the last exception caught by runEnhancer. May be null.
     */
    public static Exception getLastRunEnhancerException()
    {
        return sLastException;
    }
    
    //----------------------------------------------------------------------
    /**
     * Enhance all classes specified by the metadata.
     *
     * @throws Exception if an error occurs.
     */
    void enhanceClasses() throws Exception
    {
        Iterator allClasses = mMetaData.getAllSourceClasses();
        long startAll = System.currentTimeMillis();
        int numClasses = 0;
        long elapsedTotal = 0;
        while (allClasses.hasNext()) {
            String className = (String)allClasses.next();
            if (mMetaData.isClassEnhanceable(className)) {
                long start = System.currentTimeMillis();
                enhance(className);
                long elapsed = System.currentTimeMillis() - start;
                elapsedTotal += elapsed;
                System.out.println("Time to enhance: " + elapsed + "ms");
                ++numClasses;
            }
        }

        if (numClasses == 0) {
            // This exception is saved soley so the test classes can test this condition.
            sLastException = new Exception("Warning: No classes were enhanced.");
            System.err.println("Warning: No classes were enhanced.");
        }
        
        long elapsedAll = System.currentTimeMillis() - startAll;
        System.out.println("Enhanced " + numClasses + " classes. Total time: " + 
            elapsedAll + "ms. Avg Time per class: " + elapsedTotal / ((numClasses > 0) ? numClasses : 1));
    }
    
    //----------------------------------------------------------------------
    /**
     * Enhance the named class.
     *
     * @param aClassName the class name to be enhanced.
     *
     * @throws Exception if an error occurs.
     */
    private void enhance(String aClassName) throws Exception
    {
        ClassGen classGen = null;
        JavaClass javaClass;

        if ((javaClass = Repository.lookupClass(aClassName)) == null) {
            // Shouldn't happen unless BCEL is screwed up...
            throw new Exception("Oh shoot! I found it then I lost it: Class " + aClassName);
        }

        // If this class already implements Persistable, don't enhance it.
+        String[] interfaceNames = javaClass.getInterfaceNames();
        for (int i = 0; i < interfaceNames.length; i++) {
            if (interfaceNames[i].equals(sPersistableClassName) ||
                interfaceNames[i].equals(sPersistentAwareClassName)) {
                System.out.println("Class " + aClassName + " has already been enhanced - skipping.");
                return;
            }
        }

        System.out.println("Enhancing class: " + aClassName);
---
        boolean isOnlyPersistentAware = mMetaData.isClassOnlyPersistentAware(aClassName);
        boolean isPersistable = !isOnlyPersistentAware;

        // This is the top-level persistable class if the super-class is not a true Persistable.
        String superClassName = javaClass.getSuperclassName();
        boolean isTopLevelPersistable = isPersistable && !mMetaData.isClassAFCO(superClassName);

        // Save the original class bytes to write to the DB schema.
        byte[] originalClassBytes = null;
        if (mDatabase != null && isPersistable) {
            mByteStream.reset();
            javaClass.dump(mByteStream);
            
            originalClassBytes = mByteStream.toByteArray();
        }
---        
        classGen = new ClassGen(javaClass);

        // If this is the top-level Persistable class, add the enerj_ fields, and enerj_ core methods to it.
        if (isTopLevelPersistable) {
            enhanceTopLevelClass(classGen);
        }
        else if (isOnlyPersistentAware) {
            classGen.addInterface(sPersistentAwareClassName);
        }
--
        // Determine the class' CID. See if the class is a system peristable first.
        long classId = ObjectServer.NULL_CID;
        if (isPersistable) {
            classId = SystemCIDMap.getSystemCIDForClassName(aClassName);
            if (classId == ObjectServer.NULL_CID) {
                if (mDatabase == null) {
                    throw new Exception(aClassName + " is not a system persistable, so the --database parameter must be specified.");
                }
                
                classId = generateClassId(originalClassBytes);
            }
            else if (mDatabase != null) {
                throw new Exception(aClassName + " is a system persistable, so the --database parameter must NOT be specified.");
            }
        }
        
        ArrayList<Field> persistentFields = new ArrayList<Field>(100);
        ArrayList<Field> transientFields = new ArrayList<Field>(100);
--
        if (isPersistable) {
            // Add appropriate Persistable interface
-            classGen.addInterface(sPersistableClassName);
--
            // Generate methods to replace field access.
            Field[] fields = javaClass.getFields();

            // Make sure field overrides actually exist in the class
            mMetaData.validateFieldOverrides(aClassName, fields);

            for (int i = 0; i < fields.length; i++) {
                // Mediation methods are generated for all fields, even transients
                // so that schema evolution proxies will operate on the delegate of
                // the proxy.
                if (mMetaData.isFieldPersistent(aClassName, fields[i].getName(), fields[i])) {
                    // Persistent field...
                    persistentFields.add(fields[i]);
                    emitPersistentFieldMediationMethods(classGen, fields[i]);
                }
                else {
                    // Transient field...
                    transientFields.add(fields[i]);
                    if (fields[i].isStatic()) {
                        emitStaticFieldMediationMethods(classGen, fields[i]);
                    }
                    else {
                        emitTransientFieldMediationMethods(classGen, fields[i]);
                    }
                }
            }
----
        }


        // Enhance the methods 
        boolean hasNoArgConstructor = false;
        boolean hasPostLoad = false;
        boolean hasPreStore = false;
        boolean hasPostStore = false;
        boolean hasPreHollow = false;
        boolean enhancedClone = false;
        Method[] methods = javaClass.getMethods();
        for (int i = 0; i < methods.length; i++) {
            // Don't enhance "enerj_", abstract, or native methods
            String methodName = methods[i].getName();
            if (methodName.startsWith("enerj_") ||
                methods[i].isAbstract() || methods[i].isNative()) {
                continue;
            }

            // Is it a constructor?
            if (methodName.equals("<init>") && isPersistable) {
                if (isTopLevelPersistable) {
                    // For top-level persistable classes, don't enhance a constructor's 
                    // getfield/putfields, but do special enhancement to set 'new', etc.
                    enhanceConstructor(classGen, methods, i);
                }
                // else non-top-level Persistable. Do not change constructor.

                if (methods[i].getSignature().equals("()V")) {
                    hasNoArgConstructor = true;
                }
            }

            if (methodName.equals("clone") && isTopLevelPersistable) {
                // Enhance clone() on top-level Persistables
                enhanceClone(classGen, methods, i);
                enhancedClone = true;
            }

            // Enhance method getfield/putfield/getstatic/putstatic access.
            // Yes, even <init> and <clinit> are enhanced because they could
            // create and access fields of other Persistables.
            String sig = methods[i].getSignature();
            Type returnType = Type.getReturnType(sig);
            Type[] argTypes = Type.getArgumentTypes(sig);
            if (returnType.equals(Type.EnerJID) && argTypes.length == 0) {
                if (methodName.equals(sPostLoadMethodName)) {
                    hasPostLoad = true;
                }
                else if (methodName.equals(sPreStoreMethodName)) {
                    hasPreStore = true;
                }
                else if (methodName.equals(sPostStoreMethodName)) {
                    hasPostStore = true;
                }
                else if (methodName.equals(sPreHollowMethodName)) {
                    hasPreHollow = true;
                }
            }

            // Enhance everything but <clinit> (static initializer)
            if ( !methodName.equals("<clinit>")) {
                replaceFieldAccess(classGen, methods, i);
            }
---
        }
        
        if (isTopLevelPersistable && !enhancedClone) {
            // If we didn't find a clone method, generate one, even if the class doesn't implement Cloneable.
            emitClone(classGen);
        }

        if (isPersistable) {
            // Emit constructor used to instantiate objects from the databse.
            emitSpecialConstructor(classGen, isTopLevelPersistable, hasNoArgConstructor);

            // Generate enerj_ReadObject and enerj_WriteObject methods.
            emitReadWriteObject(classGen, persistentFields, isTopLevelPersistable, 
                hasPostLoad, hasPreStore, hasPostStore);

            emitHollow(classGen, persistentFields, isTopLevelPersistable, hasPreHollow);

            // Emit the class id static variable and getter on every Persistable.
            emitClassId(classGen);
            
            // Configure <clinit> to initialize the class Id.
            enhanceClassInit(classGen, classId);
---        }


        // Rewrite class.
        // If not updating a database schema or PersistentAware, write class to file.
        String destPathToClass;
        if (mInPlace) {
            destPathToClass = mMetaData.getSourceClassFileName(aClassName);
        }
        else {
            destPathToClass = mDestDir + File.separatorChar + aClassName.replace('.', File.separatorChar) + ".class";
        }

        // For Persistable classes, update the database schema.
        if (mDatabase != null && isPersistable) {
            updateSchema(aClassName, classId, originalClassBytes, classGen, persistentFields, transientFields);
        }
        else if (mDatabase == null && isPersistable) {
            System.out.println("System Class Id: " + classId);
        }

        // Write the class back out to the filesystem.
        // This MUST be done AFTER the schema is updated because the CID may be updated there.
        javaClass = classGen.getJavaClass();
        System.out.println("Writing enhanced class to: " + destPathToClass);
        javaClass.dump(destPathToClass);

        // Reload class to test sanity
        // @todo make this an option.
        /*
        javaClass = new ClassParser(destPathToClass).parse();
        System.out.println(javaClass);
        disassembleMethods(javaClass);
        */
----
    }

    //----------------------------------------------------------------------
    /**
     * Updates the database schema with the enhanced class, if necessary.
     * NOTE: This may update the class Id contained in aJavaClass.
     *
     * @param aClassName the class name.
     * @param aClassId the class Id that was used for enhancement.
     * @param anOriginalBytecodeDef the original bytecodes for the class, prior to enhancement.
     * @param aClassGen the class' ClassGen.
     * @param somePersistentFields the persistent fields of the class.
     * @param someTransientFields the transient fields of the class.
     *
     * @throws Exception if an error occurs.
     */
---    private void updateSchema(String aClassName, long aClassId, byte[] anOriginalBytecodeDef, ClassGen aClassGen, 
                    ArrayList somePersistentFields, ArrayList someTransientFields) throws Exception
    {
        // Do a preliminary dump. We may have to re-dump if the class Id needs to change.
        JavaClass javaClass = aClassGen.getJavaClass();
        mByteStream.reset();
        javaClass.dump(mByteStream);
        byte[] enhancedClassBytes = mByteStream.toByteArray();

        LogicalClassSchema logicalClass = mSchema.findLogicalClass(aClassName);
        if (logicalClass == null) {
            logicalClass = new LogicalClassSchema(mSchema, aClassName, "");
            mSchema.addLogicalClass(logicalClass);
        }

        // Get the latest version of this class to see if it is the same as what we
        // generated.
        ClassVersionSchema classVersion = logicalClass.getLatestVersion();
        boolean addVersion;
        if (classVersion == null) {
            // First version of the class. CID was already allocated. Class was enhanced
            // with the newly allocated CID (aClassId).
            addVersion = true;
        }
        else if (Arrays.equals(anOriginalBytecodeDef, classVersion.getOriginalBytecodes())) {
            // Not the first version of the class, but UNenhanced bytecodes are the same, 
            // hence the class is not really a new version. 
            addVersion = false;
            assert aClassId == classVersion.getClassId();
            System.out.println("Class " + aClassName + ", CID " + Long.toHexString(aClassId) + ", has already been enhanced in the schema at: " + mDatabaseURI);
        }
        else {
            // Class is not the first version and it is different from the last version.
            addVersion = true;
        }
        

        if (addVersion) {
            String[] persistentFieldNames = new String[ somePersistentFields.size() ];
            for (int i = 0; i < persistentFieldNames.length; i++) {
                Field field = (Field)somePersistentFields.get(i);
                persistentFieldNames[i] = field.getName();
            }
            
            String[] transientFieldNames = new String[ someTransientFields.size() ];
            for (int i = 0; i < transientFieldNames.length; i++) {
                Field field = (Field)someTransientFields.get(i);
                transientFieldNames[i] = field.getName();
            }
            
            String[] superTypeNames = resolveSuperTypes(javaClass);
            
            classVersion = new ClassVersionSchema(logicalClass, aClassId,
                superTypeNames, anOriginalBytecodeDef, enhancedClassBytes, persistentFieldNames, transientFieldNames);

            logicalClass.addVersion(classVersion);
            System.out.println("Writing enhanced class " + aClassName + ", CID " + Long.toHexString(aClassId) + ", to schema at: " + mDatabaseURI);
        }
    }
    
    //----------------------------------------------------------------------
    /**
     * Resolve superclasses and superinterfaces without using the Java classloader.
     *
     * @return an array of supertype names. Every class will contain at least one: java.lang.Object.
     *
     * @throws Exception in the event of an error.
     */
--    private static String[] resolveSuperTypes(JavaClass aClass) throws Exception
    {
        Set superTypeNames = new HashSet(20);

        // Do all superclasses first.
        JavaClass currentClass = aClass;
        String superClassName;
        while ((superClassName = currentClass.getSuperclassName()) != null) {
            superTypeNames.add(superClassName);
            if (superClassName.equals("java.lang.Object")) {
                break;
            }
            
            if ((currentClass = Repository.lookupClass(superClassName)) == null) {
                throw new Exception("Cannot find superclass " + superClassName + " of class " + aClass.getClassName());
            }
        }

        // Get all interface names.
        resolveInterfaceNames(aClass, superTypeNames);

        String[] returnSuperTypeNames = new String[ superTypeNames.size() ];
        superTypeNames.toArray(returnSuperTypeNames);
        return returnSuperTypeNames;
    }
    
    //----------------------------------------------------------------------
    /**
     * Resolve all superinterface names recursively and add them to someNames.
     *
     * @param aClass the class or interface to resolve the superinterfaces on.
     * @param someNames a Set that will receive the interface names.
     *
     * @throws Exception if an error occurs.
     */
--    private static void resolveInterfaceNames(JavaClass aClass, Set someNames) throws Exception
    {
        String[] interfaces = aClass.getInterfaceNames();
        for (int i = 0; i < interfaces.length; i++) {
            someNames.add(interfaces[i]);
            JavaClass interfaceClass = Repository.lookupClass(interfaces[i]);
            if (interfaceClass == null) {
                throw new Exception("Cannot find interface " + interfaces[i] + " of class " + aClass.getClassName());
            }
            resolveInterfaceNames(interfaceClass, someNames);
        }
    }

    //----------------------------------------------------------------------
    /**
     * Modify a top-level Persistable class to add the core "enerj_" fields and methods.
     * This generally implements the Persistable interface.
     */
--    private void enhanceTopLevelClass(ClassGen aClassGen)
    {
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();

        // enerj_ Fields
        FieldGen fieldGen;

        String[] boolFields = { "enerj_mModified", "enerj_mNew", "enerj_mLoaded", 
            "enerj_mAllowNonTransactionalReads", "enerj_mAllowNonTransactionalWrites" };
        for (int i = 0; i < boolFields.length; i++) {
            fieldGen = new FieldGen(Constants.ACC_PROTECTED | Constants.ACC_TRANSIENT,
                            Type.BOOLEAN, boolFields[i], constantPoolGen);
            fieldGen.update();
            aClassGen.addField( fieldGen.getField() );
        }

        fieldGen = new FieldGen(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT, 
                        Type.LONG, "enerj_mVersion", constantPoolGen);
        fieldGen.update();
        aClassGen.addField( fieldGen.getField() );

        fieldGen = new FieldGen(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT,
                        Type.LONG, "enerj_mOID", constantPoolGen);
        fieldGen.update();
        aClassGen.addField( fieldGen.getField() );

        fieldGen = new FieldGen(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT,
                        sEnerJDatabaseType, "enerj_mDatabase", constantPoolGen);
        fieldGen.update();
        aClassGen.addField( fieldGen.getField() );

        fieldGen = new FieldGen(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT,
                        Type.INT, "enerj_mLockLevel", constantPoolGen);
        fieldGen.update();
        aClassGen.addField( fieldGen.getField() );

        
        // Methods
        //   Simple Accessors
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_IsModified", "enerj_mModified");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_IsNew", "enerj_mNew");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_IsLoaded", "enerj_mLoaded");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_AllowsNonTransactionalRead", "enerj_mAllowNonTransactionalReads");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_AllowsNonTransactionalWrite", "enerj_mAllowNonTransactionalWrites");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.LONG, "enerj_GetVersion", "enerj_mVersion");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.LONG, "enerj_GetPrivateOID", "enerj_mOID");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            sEnerJDatabaseType, "enerj_GetDatabase", "enerj_mDatabase");
        emitAccessorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.INT, "enerj_GetLockLevel", "enerj_mLockLevel");

        //   Simple Mutators
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_SetModified", "enerj_mModified");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_SetNew", "enerj_mNew");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_SetLoaded", "enerj_mLoaded");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_SetAllowNonTransactionalRead", "enerj_mAllowNonTransactionalReads");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.BOOLEAN, "enerj_SetAllowNonTransactionalWrite", "enerj_mAllowNonTransactionalWrites");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.LONG, "enerj_SetVersion", "enerj_mVersion");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.LONG, "enerj_SetPrivateOID", "enerj_mOID");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            sEnerJDatabaseType, "enerj_SetDatabase", "enerj_mDatabase");
        emitMutatorMethod(aClassGen, Constants.ACC_PUBLIC | Constants.ACC_FINAL,
            Type.INT, "enerj_SetLockLevel", "enerj_mLockLevel");
    }

    //----------------------------------------------------------------------
    /**
     * Finish adding a method to a class. anInstructionList is disposed by
     * this method.
     */
--    private void addMethod(ClassGen aClassGen, MethodGen aMethodGen, InstructionList anInstructionList)
    {
        // This is a generated method, so the VM spec says it must be synthetic.
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        int syntheticIdx = constantPoolGen.addUtf8("Synthetic");
        aMethodGen.addAttribute(  new Synthetic(syntheticIdx, 0, null, constantPoolGen.getConstantPool()) );
        
        anInstructionList.update();
        aMethodGen.update();
        // Compute stack
        aMethodGen.setMaxStack();
        aClassGen.addMethod( aMethodGen.getMethod() );
        aClassGen.update();

        // Reuse instruction handles
        anInstructionList.dispose();
    }

    //----------------------------------------------------------------------
    /**
     * Emit a simple, generic accessor method.
     */
-    private void emitAccessorMethod(ClassGen aClassGen, int someAccessFlags,
                    Type aType, String aMethodName, String aFieldName)
    {
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(someAccessFlags, aType, Type.NO_ARGS, sNoArgNames,
            aMethodName, aClassGen.getClassName(), instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createGetField(aClassGen.getClassName(), aFieldName, aType) );
        instructions.append( factory.createReturn(aType) );

        addMethod(aClassGen, methodGen, instructions);
    }

    //----------------------------------------------------------------------
    /**
     * Emit a simple, generic mutator method.
     */
-    private void emitMutatorMethod(ClassGen aClassGen, int someAccessFlags,
                    Type aType, String aMethodName, String aFieldName)
    {
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(someAccessFlags, Type.EnerJID,
            new Type[] { aType },  new String[] { aFieldName },
            aMethodName, aClassGen.getClassName(), instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createLoad(aType, 1) );
        instructions.append( factory.createPutField(aClassGen.getClassName(), aFieldName, aType) );
        instructions.append( InstructionConstants.RETURN );

        addMethod(aClassGen, methodGen, instructions);
    }

    //----------------------------------------------------------------------
    /**
     * Emits the class Id static variable and a static and non-static getters for it.
     */
-    private void emitClassId(ClassGen aClassGen)
    {
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();

        // Emit static field
        FieldGen fieldGen = new FieldGen(Constants.ACC_PRIVATE | Constants.ACC_STATIC | Constants.ACC_TRANSIENT,
                        Type.LONG, sClassIdFieldName, constantPoolGen);
        fieldGen.update();
        aClassGen.addField( fieldGen.getField() );

        // Emit static getter. We'll use this when we only have a class and not an object.
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(Constants.ACC_PUBLIC | Constants.ACC_STATIC | Constants.ACC_FINAL,
            Type.LONG, Type.NO_ARGS, sNoArgNames,
            "enerj_GetClassIdStatic", aClassGen.getClassName(), instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( factory.createGetStatic(aClassGen.getClassName(), sClassIdFieldName, Type.LONG) );
        instructions.append( factory.createReturn(Type.LONG) );

        addMethod(aClassGen, methodGen, instructions);

        // Emit non-static Persistable interface getter. 
        // We'll use for non-reflective access when we have a Persistable.
        instructions = new InstructionList();

        methodGen = new MethodGen(Constants.ACC_PUBLIC,
            Type.LONG, Type.NO_ARGS, sNoArgNames,
            "enerj_GetClassId", aClassGen.getClassName(), instructions, constantPoolGen);

        factory = new InstructionFactory(constantPoolGen);

        instructions.append( factory.createGetStatic(aClassGen.getClassName(), sClassIdFieldName, Type.LONG) );
        instructions.append( factory.createReturn(Type.LONG) );

        addMethod(aClassGen, methodGen, instructions);
    }
    
    //----------------------------------------------------------------------
    /**
     * Emits the &lt;clinit> method when one does not already exist.
     * Initializes the value of the class Id.
     */
-    private void emitClassInit(ClassGen aClassGen, long aClassId)
    {
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(Constants.ACC_STATIC, Type.EnerJID, Type.NO_ARGS, sNoArgNames,
            "<clinit>", aClassGen.getClassName(), instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( new LDC2_W( constantPoolGen.addLong(aClassId) ) );
        instructions.append( factory.createPutStatic(aClassGen.getClassName(), sClassIdFieldName, Type.LONG) );
        instructions.append( InstructionConstants.RETURN );

        addMethod(aClassGen, methodGen, instructions);
    }

    //----------------------------------------------------------------------
    /**
     * Enhances the existing &lt;clinit> method to initialize the value of the class Id.
     * If the method already contains code to set enerj_sClassId, the class Id value
     * is changed to aClassId. 
     * If the method does not exist, a new &lt;clinit> method is generated.
     */
-    private void enhanceClassInit(ClassGen aClassGen, long aClassId) throws Exception
    {
        Method[] methods = aClassGen.getMethods();
        Method method = null;
        int methodIndex = 0;
        for (; methodIndex < methods.length; methodIndex++) {
            if (methods[methodIndex].getName().equals("<clinit>")) {
                method = methods[methodIndex];
                break;
            }
        }
        
        if (method == null) {
            emitClassInit(aClassGen, aClassId);
            return;
        }
        
        Code code = method.getCode();
        if (code == null) {
            // This shouldn't happen.
            throw new Exception("Expected code for <clinit>");
        }

        String className = aClassGen.getClassName();

        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionFactory factory = new InstructionFactory(constantPoolGen);
        MethodGen methodGen = new MethodGen(method, className, constantPoolGen);

        InstructionList instructionList = methodGen.getInstructionList();
        InstructionHandle handle = instructionList.getStart();
        for (; handle != null; handle = handle.getNext() ) {
            Instruction instruction = handle.getInstruction();
            short opcode = instruction.getOpcode();
            if (opcode == Constants.RETURN) {
                // We haven't found a previously inserted set of instructions yet, so insert
                // them at the end.
                instructionList.insert(handle, new LDC2_W( constantPoolGen.addLong(aClassId) ) );
                instructionList.insert(handle, factory.createPutStatic(className, sClassIdFieldName, Type.LONG) );
                break;
            }
            else if (opcode == Constants.PUTSTATIC) {
                FieldInstruction fieldInstruction = (FieldInstruction)instruction;
                String fieldName = fieldInstruction.getFieldName(constantPoolGen);
                String fieldClassName = fieldInstruction.getClassName(constantPoolGen);
                
                // Is it the enerj_sClassId field of this class?
                if (fieldClassName.equals(className) && fieldName.equals(sClassIdFieldName)) {
                    // Backup to the LDC2_W and modify the referenced constant pool entry.
                    // Don't add constant pool entries at this point!
                    InstructionHandle pushHandle = handle.getPrev();
                    LDC2_W ldc2wInstruction = (LDC2_W)pushHandle.getInstruction();
                    int constantPoolIndex = ldc2wInstruction.getIndex();
                    ConstantLong constantLong = (ConstantLong)constantPoolGen.getConstant(constantPoolIndex);
                    constantLong.setBytes(aClassId);
                    break; // We're done.
                }
            }
        }

        instructionList.update();

        methodGen.update();
        // Recompute stack size
        methodGen.setMaxStack();
        aClassGen.setMethodAt(methodGen.getMethod(), methodIndex);
        aClassGen.update();

        // Reuse instruction handles
        instructionList.dispose();
    }

    //----------------------------------------------------------------------
    /**
     * Create the method name suffix used for a field getter or setter.
     *
     * @param aClassName a fully qualified class name (with dots).
     * @param aFieldName the field's name.
     *
     * @return the method name suffix.
     */
--    private String getFieldMethodNameSuffix(String aClassName, String aFieldName) 
    {
        // Change '.'s in class name to '_'
        char[] className = new char[ aClassName.length() ];
        aClassName.getChars(0, className.length, className, 0);
        for (int i = 0; i < className.length; i++) {
            if (className[i] == '.') {
                className[i] = '_';
            }
        }
        
        return new String(className) + '_' + aFieldName;
    }

    //----------------------------------------------------------------------
    /**
     * Generate the getfield/putfield replacement methods (enerj_Get_* and enerj_Set_*)
     * for persistent fields.
     * Parameters to the generated methods conveniently match the stack frame of
     * getfield and putfield.
     *
     * @param aClassGen the ClassGen representing the class of aField.
     * @param aField a Field for which the methods will be generated.
     */
--    private void emitPersistentFieldMediationMethods(ClassGen aClassGen, Field aField)
    {
        int fieldScope = aField.getAccessFlags() &
                            ( Constants.ACC_PRIVATE | Constants.ACC_PUBLIC | Constants.ACC_PROTECTED );
        
        String className = aClassGen.getClassName();
        ObjectType classType = new ObjectType(className);
        String fieldName = aField.getName();
        String fieldSignature = aField.getSignature();
        Type fieldType = Type.getType(fieldSignature);
        String methodNameSuffix = getFieldMethodNameSuffix(className, fieldName);
        
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();

        // Accessor (Getter)
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(
            fieldScope | Constants.ACC_STATIC,
            fieldType, new Type[] { classType }, new String[] { "obj" },
            FIELD_ACCESSOR_PREFIX + methodNameSuffix, className, instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        // Check if checkLoaded needs to be called. Call if (!enerj_mLoaded && !enerj_mNew)
        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createGetField(className, "enerj_mLoaded", Type.BOOLEAN) );
        BranchHandle checkTargeter1 = instructions.append( new IFNE(null) );
        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createGetField(className, "enerj_mNew", Type.BOOLEAN) );
        BranchHandle checkTargeter2 = instructions.append( new IFNE(null) );
        
        // Call checkLoaded
        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( InstructionConstants.ICONST_0 ); // false
        instructions.append( factory.createInvoke(sPersistableHelperClassName, "checkLoaded", Type.EnerJID, 
                                sCheckLoadedArgs, Constants.INVOKESTATIC) );

        // Get the field value and return it
        InstructionHandle getHandle = instructions.append( InstructionConstants.ALOAD_0 );
        checkTargeter1.setTarget(getHandle);
        checkTargeter2.setTarget(getHandle);
        // Make sure we don't reference these again until they're set
        checkTargeter1 = null; 
        checkTargeter2 = null;
        instructions.append( factory.createGetField(className, fieldName, fieldType) );

        instructions.append( factory.createReturn(fieldType) );

        addMethod(aClassGen, methodGen, instructions);

        // Mutator (Setter). Because of the == comparison, the method is a little different
        // for primitives, Strings (final class that implements equals() properly), and regular objects.
        instructions = new InstructionList();

        methodGen = new MethodGen(
            fieldScope | Constants.ACC_STATIC,
            Type.EnerJID, new Type[] { classType, fieldType }, new String[] { "obj", "value" },
            FIELD_MUTATOR_PREFIX + methodNameSuffix, className, instructions, constantPoolGen);

        // Check if checkLoaded needs to be called. Call if (!enerj_mLoaded && !enerj_mNew)
        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createGetField(className, "enerj_mLoaded", Type.BOOLEAN) );
        checkTargeter1 = instructions.append( new IFNE(null) );
        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createGetField(className, "enerj_mNew", Type.BOOLEAN) );
        checkTargeter2 = instructions.append( new IFNE(null) );
        
        // Call checkLoaded
        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( InstructionConstants.ICONST_1 ); // true
        instructions.append( factory.createInvoke(sPersistableHelperClassName, "checkLoaded", Type.EnerJID, 
                                sCheckLoadedArgs, Constants.INVOKESTATIC) );

        // Check if the field's value is actually changing. For primitives, we use ==;
        // for special classes declared final (e.g., String, Integer), we use equals(); 
        // and for other objects we use == (identity).
        BranchHandle returnTargeter;
        BranchHandle returnTargeter2 = null;
        BranchHandle storeTargeter = null;
        InstructionHandle setHandle;

        if (mMetaData.isPrimitive(fieldSignature)) {
            // Push parameter 1 - the new value
            setHandle = instructions.append( factory.createLoad(fieldType, 1) );
            // This
            instructions.append( InstructionConstants.ALOAD_0 );
            // Current value
            instructions.append( factory.createGetField(className, fieldName, fieldType) ); 

            char type = fieldSignature.charAt(0);
            switch (type) {
            case 'B':
            case 'Z':
            case 'C':
            case 'S':
            case 'I':
                returnTargeter = instructions.append( new IF_ICMPEQ(null) );
                break;

            case 'F':
                instructions.append( InstructionConstants.FCMPL );
                returnTargeter = instructions.append( new IFEQ(null) );
                break;

            case 'J':
                instructions.append( InstructionConstants.LCMP );
                returnTargeter = instructions.append( new IFEQ(null) );
                break;

            case 'D':
                instructions.append( InstructionConstants.DCMPL );
                returnTargeter = instructions.append( new IFEQ(null) );
                break;
                
            default:
                throw new RuntimeException("Unknown primitive type: " + type);
            }
        }
        else if (fieldSignature.equals("Ljava/lang/String;") ||
                 fieldSignature.equals("Ljava/lang/Integer;") ||
                 fieldSignature.equals("Ljava/lang/Long;") ||
                 fieldSignature.equals("Ljava/lang/Byte;") ||
                 fieldSignature.equals("Ljava/lang/Boolean;") ||
                 fieldSignature.equals("Ljava/lang/Character;") ||
                 fieldSignature.equals("Ljava/lang/Short;") ||
                 fieldSignature.equals("Ljava/lang/Float;") ||
                 fieldSignature.equals("Ljava/lang/Double;") ) {
                     
            // One of the core final immutable types. Use equals() to compare values, like this:
            // "if ((aValue == null{1} && anInstance.mString != null{2}) || (aValue != null{3} && !aValue.equals(anInstance.mString){4})" ...
            // {1}: aValue == null
            setHandle = instructions.append( InstructionConstants.ALOAD_1 );
            BranchHandle equalsTargeter = instructions.append( new IFNONNULL(null) );

            // {2}: anInstance.mString != null
            instructions.append( InstructionConstants.ALOAD_0 );
            instructions.append( factory.createGetField(className, fieldName, fieldType) ); // Current value
            storeTargeter = instructions.append( new IFNONNULL(null) );
            
            // {3}: aValue != null
            instructions.append( InstructionConstants.ALOAD_1 );
            returnTargeter2 = instructions.append( new IFNULL(null) );

            // {4}: equals()...
            // Push parameter 1 - the new value
            InstructionHandle equalsTarget = instructions.append( factory.createLoad(fieldType, 1) ); 
            equalsTargeter.setTarget(equalsTarget);
            instructions.append( InstructionConstants.ALOAD_0 );
            // Current value
            instructions.append( factory.createGetField(className, fieldName, fieldType) ); 
            instructions.append( factory.createInvoke(((ObjectType)fieldType).getClassName(), "equals", Type.BOOLEAN, 
                sObjectArg, Constants.INVOKEVIRTUAL) );
            returnTargeter = instructions.append( new IFNE(null) );
        }
        else {
            // Some other Object -- use identity ==
            // Push parameter 1 - the new value
            setHandle = instructions.append( factory.createLoad(fieldType, 1) );
            instructions.append( InstructionConstants.ALOAD_0 );
            // Current value
            instructions.append( factory.createGetField(className, fieldName, fieldType) );
            returnTargeter = instructions.append( new IF_ACMPEQ(null) );
        }

        // Store the value
        // Mark owner object as modified - short circuit if already marked modified
        InstructionHandle storeTarget = instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createGetField(className, "enerj_mModified", Type.BOOLEAN) );
        BranchHandle modifiedTargeter = instructions.append( new IFNE(null) );

        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createInvoke(sPersistableHelperClassName, "addModified", Type.EnerJID, 
                                sPersistableArg, Constants.INVOKESTATIC) );

        InstructionHandle putfieldTarget = instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createLoad(fieldType, 1) ); // Push parameter 1
        instructions.append( factory.createPutField(className, fieldName, fieldType) );

        InstructionHandle returnTarget = instructions.append( InstructionConstants.RETURN );
        returnTargeter.setTarget(returnTarget);
        if (returnTargeter2 != null) {
            returnTargeter2.setTarget(returnTarget);
        }
        
        modifiedTargeter.setTarget(putfieldTarget);
        checkTargeter1.setTarget(setHandle);
        checkTargeter2.setTarget(setHandle);
        if (storeTargeter != null) {
            storeTargeter.setTarget(storeTarget);
        }

        addMethod(aClassGen, methodGen, instructions);
    }

    //----------------------------------------------------------------------
    /**
     * Generate the getfield/putfield replacement methods (enerj_Get_* and enerj_Set_*)
     * for non-static transient fields.
     * Parameters to the generated methods conveniently match the stack frame of
     * getfield and putfield.
     *
     * @param aClassGen the ClassGen representing the class of aField.
     * @param aField a Field for which the methods will be generated.
     */
--    private void emitTransientFieldMediationMethods(ClassGen aClassGen, Field aField)
    {
        int fieldScope = aField.getAccessFlags() &
                            ( Constants.ACC_PRIVATE | Constants.ACC_PUBLIC | Constants.ACC_PROTECTED );
        
        String className = aClassGen.getClassName();
        ObjectType classType = new ObjectType(className);
        String fieldName = aField.getName();
        String fieldSignature = aField.getSignature();
        Type fieldType = Type.getType(fieldSignature);
        String methodNameSuffix = getFieldMethodNameSuffix(className, fieldName);
        
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();

        // Accessor (Getter).
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(
            fieldScope | Constants.ACC_STATIC,
            fieldType, new Type[] { classType }, new String[] { "obj" },
            FIELD_ACCESSOR_PREFIX + methodNameSuffix, className, instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createGetField(className, fieldName, fieldType) );
        instructions.append( factory.createReturn(fieldType) );

        addMethod(aClassGen, methodGen, instructions);

        // Mutator (Setter).
        instructions = new InstructionList();

        methodGen = new MethodGen(
            fieldScope | Constants.ACC_STATIC,
            Type.EnerJID, new Type[] { classType, fieldType }, new String[] { "obj", "value" },
            FIELD_MUTATOR_PREFIX + methodNameSuffix, className, instructions, constantPoolGen);

        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createLoad(fieldType, 1) ); // Push parameter 1
        instructions.append( factory.createPutField(className, fieldName, fieldType) );
        instructions.append( InstructionConstants.RETURN );

        addMethod(aClassGen, methodGen, instructions);
    }

    //----------------------------------------------------------------------
    /**
     * Generate the getstatic/putstatic replacement methods (enerj_Get_* and enerj_Set_*)
     * for static transient fields. 
     * Parameters to the generated methods conveniently match the stack frame of
     * getstatic and putstatic.
     *
     * @param aClassGen the ClassGen representing the class of aField.
     * @param aField a Field for which the methods will be generated.
     */
--    private void emitStaticFieldMediationMethods(ClassGen aClassGen, Field aField)
    {
        int fieldScope = aField.getAccessFlags() &
                            ( Constants.ACC_PRIVATE | Constants.ACC_PUBLIC | Constants.ACC_PROTECTED );
        
        String className = aClassGen.getClassName();
        ObjectType classType = new ObjectType(className);
        String fieldName = aField.getName();
        String fieldSignature = aField.getSignature();
        Type fieldType = Type.getType(fieldSignature);
        String methodNameSuffix = getFieldMethodNameSuffix(className, fieldName);
        
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();

        // Accessor (Getter).
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(
            fieldScope | Constants.ACC_STATIC,
            fieldType, Type.NO_ARGS, null,
            FIELD_ACCESSOR_PREFIX + methodNameSuffix, className, instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( factory.createGetStatic(className, fieldName, fieldType) );
        instructions.append( factory.createReturn(fieldType) );

        addMethod(aClassGen, methodGen, instructions);

        // Mutator (Setter).
        instructions = new InstructionList();

        methodGen = new MethodGen(
            fieldScope | Constants.ACC_STATIC,
            Type.EnerJID, new Type[] { fieldType }, new String[] { "value" },
            FIELD_MUTATOR_PREFIX + methodNameSuffix, className, instructions, constantPoolGen);

        instructions.append( factory.createLoad(fieldType, 0) ); // Push parameter 0
        instructions.append( factory.createPutStatic(className, fieldName, fieldType) );
        instructions.append( InstructionConstants.RETURN );

        addMethod(aClassGen, methodGen, instructions);
    }

    //----------------------------------------------------------------------
    /**
     * Emit the special constructor. "&lt;init>(EnerJDatabase)".
     *
     * @param aClassGen the ClassGen of the class.
     * @param isTopLevelPersistable true if this is a top-level persistable class.
     * @param hasNoArgConstructor indicates whether a top-level persistable has a
     *  no-arg constructor. Only applies when isTopLevelPersistable is true.
     */
-    private void emitSpecialConstructor(ClassGen aClassGen, boolean isTopLevelPersistable,
        boolean hasNoArgConstructor)
    {
        String className = aClassGen.getClassName();
        String superClassName = aClassGen.getSuperclassName();
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(Constants.ACC_PUBLIC, 
            Type.EnerJID, sEnerJDatabaseArg,  sEnerJDatabaseArgName,
            "<init>", aClassGen.getClassName(), instructions, constantPoolGen);

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( InstructionConstants.ALOAD_0 );
        Type[] args; 
        String constructorClass = superClassName;
        if (isTopLevelPersistable) {
            // Super-class is not Persistable, call default constructor
            args = Type.NO_ARGS;
            if (hasNoArgConstructor) {
                // Use this class' no-arg constructor rather than the super-class'.
                // The super-class might not have an exposed no-arg constructor.
                // However, this also causes PersistableHelper.initPersistable to be called since
                // the default constructor was enhanced to do so. This has side-effect,
                // of just marking the object as "new". However, the EnerJDatabase.getObjectByOID()
                // method "undoes" the "new" flag.
                constructorClass = className;
            }
        }
        else {
            instructions.append( InstructionConstants.ALOAD_1 );
            args = sEnerJDatabaseArg;
        }

        instructions.append( factory.createInvoke(constructorClass, "<init>", Type.EnerJID, 
                             args, Constants.INVOKESPECIAL) );
        
        instructions.append( InstructionConstants.RETURN );

        addMethod(aClassGen, methodGen, instructions);
    }
    
    //----------------------------------------------------------------------
    /**
     * Enhance a constructor in a top-level persistable.
     *
     * @param aClassGen the ClassGen of the method.
     * @param someMethods the array of methods, someMethods[anIndex] may be enhanced.
     * @param anIndex the index of the method to enhance.
     */
--    private void enhanceConstructor(ClassGen aClassGen, Method[] someMethods, int anIndex)
    {
        // We look for an invokespecial on an <init> method of the superclass.
        // This eliminates enhancement on constructors that call "this(...)".
        Method method = someMethods[anIndex];
        Code code = method.getCode();
        if (code == null) {
            return;
        }

        String className = aClassGen.getClassName();
        String superClassName = aClassGen.getSuperclassName();

        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionFactory factory = new InstructionFactory(constantPoolGen);
        MethodGen methodGen = new MethodGen(method, className, constantPoolGen);

        InstructionList instructionList = methodGen.getInstructionList();
        InstructionHandle handle = instructionList.getStart();
        for (; handle != null; handle = handle.getNext() ) {
            Instruction instruction = handle.getInstruction();
            if (instruction.getOpcode() == Constants.INVOKESPECIAL) {
                InvokeInstruction invokeInstruction = (InvokeInstruction)instruction;
                if (invokeInstruction.getClassName(constantPoolGen).equals(superClassName) &&
                    invokeInstruction.getMethodName(constantPoolGen).equals("<init>")) {
                    // Found the target handle.
                    break;
                }
            }
        }
                

        if (handle != null) {
            handle = instructionList.append(handle, InstructionConstants.ALOAD_0);
            handle = instructionList.append(handle, 
                factory.createInvoke(sPersistableHelperClassName, "initPersistable", Type.EnerJID, 
                sPersistableArg, Constants.INVOKESTATIC) );

            instructionList.update();
            methodGen.update();
            // Recompute stack size
            methodGen.setMaxStack();
            aClassGen.setMethodAt(methodGen.getMethod(), anIndex);
            aClassGen.update();
        }

        // Reuse instruction handles
        instructionList.dispose();
    }
    
    //----------------------------------------------------------------------
    /**
     * Enhance the clone() method in a top-level persistable.
     *
     * @param aClassGen the ClassGen of the method.
     * @param someMethods the array of methods, someMethods[anIndex] may be enhanced.
     * @param anIndex the index of the method to enhance.
     */
-    private void enhanceClone(ClassGen aClassGen, Method[] someMethods, int anIndex)
    {
        Method method = someMethods[anIndex];
        Code code = method.getCode();
        // abstract clone? - I don't think that's possible, but we'll trap the null
        // condition anyway.
        if (code == null) {
            return;
        }

        String className = aClassGen.getClassName();

        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionFactory factory = new InstructionFactory(constantPoolGen);
        MethodGen methodGen = new MethodGen(method, className, constantPoolGen);

        // Search for areturn instruction - there may be multiple returns
        InstructionList instructionList = methodGen.getInstructionList();
        InstructionHandle handle = instructionList.getStart();
        for (; handle != null; handle = handle.getNext() ) {
            Instruction instruction = handle.getInstruction();
            if (instruction.getOpcode() == Constants.ARETURN) {
                // Found the target handle.
                // Duplicate the clone object that will be returned
                instructionList.insert(handle, InstructionConstants.DUP);
                instructionList.insert(handle, 
                    factory.createInvoke(sPersistableHelperClassName, "initPersistableClone", Type.EnerJID, 
                    sPersistableArg, Constants.INVOKESTATIC) );
            }
        }
                

        instructionList.update();
        methodGen.update();
        // Recompute stack size
        methodGen.setMaxStack();
        aClassGen.setMethodAt(methodGen.getMethod(), anIndex);
        aClassGen.update();

        // Reuse instruction handles
        instructionList.dispose();
    }
    
    //----------------------------------------------------------------------
    /**
     * Emit the special clone() method on a top-level persistable. This is
     * generated when a top-level Persistable doesn't have a clone method.
     * It ensures initPersistableClone is called if a sub-class implements clone().
     *
     * @param aClassGen the ClassGen of the class.
     */
-    private void emitClone(ClassGen aClassGen)
    {
        String className = aClassGen.getClassName();
        String superClassName = aClassGen.getSuperclassName();
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionList instructions = new InstructionList();

        MethodGen methodGen = new MethodGen(Constants.ACC_PUBLIC, 
            Type.OBJECT, Type.NO_ARGS,  sNoArgNames,
            "clone", className, instructions, constantPoolGen);

        // @todo only add this exception if superclass throws it. Object does, while java.util.Date does not.
        // @todo Either that or never throw it and wrap the super.clone() in a try/catch.
        // @todo catch part should never happen. If it does, return null.
        int exceptionsIdx = constantPoolGen.addUtf8("Exceptions");
        int[] exceptionsIdxTable = new int[] { constantPoolGen.addClass("java.lang.CloneNotSupportedException") };
        // Attribute length in bytes is 4 = 2 bytes for number of exceptions + 2 bytes for one index to an exception.
        methodGen.addAttribute(  new ExceptionTable(exceptionsIdx, 4, exceptionsIdxTable, constantPoolGen.getConstantPool()) );

        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createInvoke(superClassName, "clone", Type.OBJECT, 
                             Type.NO_ARGS, Constants.INVOKESPECIAL) );
        instructions.append( InstructionConstants.DUP );
        instructions.append( factory.createCheckCast((ReferenceType)sPersistableType) );
        instructions.append( factory.createInvoke(sPersistableHelperClassName, "initPersistableClone", Type.EnerJID, 
                                sPersistableArg, Constants.INVOKESTATIC) );
        instructions.append( InstructionConstants.ARETURN );

        addMethod(aClassGen, methodGen, instructions);
    }
    
    //----------------------------------------------------------------------
    /**
     * Replace any getfield/getstatic/putfield/putstatic instructions in the 
     * specified method which reference fields of persistable classes.
     *
     * @param aClassGen the ClassGen of the method.
     * @param someMethods the array of methods, someMethods[anIndex] may be enhanced.
     * @param anIndex the index of the method to enhance.
     */
 -   private void replaceFieldAccess(ClassGen aClassGen, Method[] someMethods, int anIndex)
    {
        Method method = someMethods[anIndex];
        Code code = method.getCode();
        if (code == null) {
            return;
        }

        // If the method is <init> or clone on a Persistable, only enhance
        // access to Persistables external to this one. This eliminates unnecessary
        // modification marking and race conditions on initialization.
        String methodName = method.getName();
        boolean externalOnly = (methodName.equals("<init>") || methodName.equals("clone"));
        
        String className = aClassGen.getClassName();

        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionFactory factory = new InstructionFactory(constantPoolGen);
        MethodGen methodGen = new MethodGen(method, className, constantPoolGen);

        Type[] getFieldArgs = new Type[1];
        Type[] putFieldArgs = new Type[2];
        Type[] putStaticArgs = new Type[1];

        boolean methodModified = false;
        InstructionList instructionList = methodGen.getInstructionList();
        InstructionHandle handle = instructionList.getStart();
        for (; handle != null; handle = handle.getNext() ) {
            Instruction instruction = handle.getInstruction();
            short opcode = instruction.getOpcode();
            if (opcode == Constants.GETFIELD || opcode == Constants.PUTFIELD ||
                opcode == Constants.GETSTATIC || opcode == Constants.PUTSTATIC) {

                FieldInstruction fieldInstruction = (FieldInstruction)instruction;
                String fieldName = fieldInstruction.getFieldName(constantPoolGen);
                String fieldClassName = fieldInstruction.getClassName(constantPoolGen);

                // The referenced field's class name must be an FCO to enhance access to it.
                // Also, if externalOnly is true, the field class name should not be the
                // the same as this class name. 
                if ( !mMetaData.isClassAFCO(fieldClassName) ||
                     (externalOnly && fieldClassName.equals(className)) ) {
                    continue;   // Skip it.
                }
                
                Type fieldClassType = new ObjectType(fieldClassName);
                Type fieldType = fieldInstruction.getFieldType(constantPoolGen);

                methodModified = true;
                String methodPrefix;
                Type[] args;
                Type returnType;
                switch (opcode) {
                case Constants.GETFIELD:
                    methodPrefix = FIELD_ACCESSOR_PREFIX;
                    args = getFieldArgs;
                    args[0] = fieldClassType;
                    returnType = fieldType;
                    break;

                case Constants.PUTFIELD:
                    methodPrefix = FIELD_MUTATOR_PREFIX;
                    args = putFieldArgs;
                    args[0] = fieldClassType;
                    args[1] = fieldType;
                    returnType = Type.EnerJID;
                    break;
                    
                case Constants.GETSTATIC:
                    methodPrefix = FIELD_ACCESSOR_PREFIX;
                    args = Type.NO_ARGS;
                    returnType = fieldType;
                    break;

                case Constants.PUTSTATIC:
                    methodPrefix = FIELD_MUTATOR_PREFIX;
                    args = putStaticArgs;
                    args[0] = fieldType;
                    returnType = Type.EnerJID;
                    break;
                    
                default:
                    throw new RuntimeException("Unexpected default case");
                }
                    
                handle.setInstruction( factory.createInvoke(fieldClassName, 
                    methodPrefix + getFieldMethodNameSuffix(fieldClassName, fieldName), 
                    returnType, args, Constants.INVOKESTATIC) );
            }
        }

        if (methodModified) {
            instructionList.update();
            methodGen.update();
            // Recompute stack size
            methodGen.setMaxStack();
            aClassGen.setMethodAt(methodGen.getMethod(), anIndex);
            aClassGen.update();
        }

        // Reuse instruction handles
        instructionList.dispose();
    }
    
    //----------------------------------------------------------------------
    /**
     * Generate the enerj_ReadObject and enerj_WriteObject methods.
     *
     * @param aClassGen the ClassGen representing the class.
     * @param someFields a list of the persistent fields for this class (not including
     *  super-class fields).
     * @param isTopLevelPersistable true if this is a top-level persistable class.
     * @param hasPostLoad true if the enerjPostLoad method exists.
     * @param hasPreStore true if the enerjPreStore method exists.
     * @param hasPostStore true if the enerjPostStore method exists.
     *
     * @throws Exception in the event of an error.
     */
-    private void emitReadWriteObject(ClassGen aClassGen, ArrayList someFields, boolean isTopLevelPersistable,
        boolean hasPostLoad, boolean hasPreStore, boolean hasPostStore)
            throws Exception
    {
        String className = aClassGen.getClassName();
        String superClassName = aClassGen.getSuperclassName();
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        InstructionList readInstructions = new InstructionList();
        MethodGen readMethodGen = new MethodGen(
            Constants.ACC_PUBLIC,
            Type.EnerJID, sReadContextArg, null,
            "enerj_ReadObject", className, readInstructions, constantPoolGen);

        InstructionList writeInstructions = new InstructionList();
        MethodGen writeMethodGen = new MethodGen(
            Constants.ACC_PUBLIC,
            Type.EnerJID, sWriteContextArg, null,
            "enerj_WriteObject", className, writeInstructions, constantPoolGen);

        // Initialize local variable 2 - "stream"
        readInstructions.append( InstructionConstants.ALOAD_1 );
        readInstructions.append( factory.createGetField(sReadContextClassName, "mStream", sDataInputType) );
        InstructionHandle readStreamStart = readInstructions.append( InstructionConstants.ASTORE_2 );

        writeInstructions.append( InstructionConstants.ALOAD_1 );
        writeInstructions.append( factory.createGetField(sWriteContextClassName, "mStream", sDataOutputType) );
        InstructionHandle writeStreamStart = writeInstructions.append( InstructionConstants.ASTORE_2 );

        // Invoke enerjPreStore if it exists
        if (hasPreStore) {
            // Use INVOKESPECIAL here rather than INVOKEVIRTUAL for two reasons:
            // 1) We want to call the method on this object ONLY, NOT an overridden
            // method in a sub-class; 2) the method may be private, in which case
            // INVOKESPECIAL should be used according to the VM Spec.
            writeInstructions.append( InstructionConstants.ALOAD_0 );
            writeInstructions.append( factory.createInvoke(className, sPreStoreMethodName, Type.EnerJID, 
                                    Type.NO_ARGS, Constants.INVOKESPECIAL) );
        }
        
        if (!isTopLevelPersistable) {
            // Call super read/write if not a top-level persistable
            readInstructions.append( InstructionConstants.ALOAD_0 );
            readInstructions.append( InstructionConstants.ALOAD_1 );
            readInstructions.append( factory.createInvoke(superClassName, "enerj_ReadObject", Type.EnerJID, 
                                    sReadContextArg, Constants.INVOKESPECIAL) );

            writeInstructions.append( InstructionConstants.ALOAD_0 );
            writeInstructions.append( InstructionConstants.ALOAD_1 );
            writeInstructions.append( factory.createInvoke(superClassName, "enerj_WriteObject", Type.EnerJID, 
                                    sWriteContextArg, Constants.INVOKESPECIAL) );
        }

        Iterator fields = someFields.iterator();
        while (fields.hasNext()) {
            Field field = (Field)fields.next();
            String fieldName = field.getName();
            String signature = field.getSignature();
            Type fieldType = Type.getType(signature);

            // This will return null if the type is not a primitive.
            String dataInOutSuffix = mMetaData.getPrimitiveDataInOutSuffix(signature);
            if (dataInOutSuffix != null) {
                // Read instructions for primitive...
                // this - For putfield
                readInstructions.append( InstructionConstants.ALOAD_0 );
                // DataInput "stream"
                readInstructions.append( InstructionConstants.ALOAD_2 );
                // Invoke read method on DataInput
                readInstructions.append( factory.createInvoke(sDataInputClassName, "read" + dataInOutSuffix, fieldType, 
                                        Type.NO_ARGS, Constants.INVOKEINTERFACE) );
                // Store the value
                readInstructions.append( factory.createPutField(className, fieldName, fieldType) );
                
                // Write instructions for primitive...
                // DataOutput "stream" - for write method
                writeInstructions.append( InstructionConstants.ALOAD_2 );
                // this - for getfield
                writeInstructions.append( InstructionConstants.ALOAD_0 );
                writeInstructions.append( factory.createGetField(className, fieldName, fieldType) );
                // Invoke write method on DataOutput
                Type argType = fieldType;
                char sigChar = signature.charAt(0);
                // Special case - Byte, Short, and Char take an int as a parameter.
                if (sigChar == 'B' || sigChar == 'S' || sigChar == 'C') {
                    argType = Type.INT;
                }
                
                writeInstructions.append( factory.createInvoke(sDataOutputClassName, "write" + dataInOutSuffix, Type.EnerJID, 
                                        new Type[] { argType }, Constants.INVOKEINTERFACE) );
            }
            else {
                // Read instructions for a SCO or FCO...
                // this - For putfield
                readInstructions.append( InstructionConstants.ALOAD_0 );
                // ReadContext - method param 1
                readInstructions.append( InstructionConstants.ALOAD_1 );
                // this - method param 2
                readInstructions.append( InstructionConstants.ALOAD_0 ); 
                // Invoke readObject - value to stack for putfield
                readInstructions.append( factory.createInvoke(sObjectSerializerClassName, "readObject", Type.OBJECT, 
                                        sReadObjectArgs, Constants.INVOKESTATIC) );
                // Cast Object result to proper type
                readInstructions.append( factory.createCheckCast((ReferenceType)fieldType) );
                // Store the value
                readInstructions.append( factory.createPutField(className, fieldName, fieldType) );

                // Write instructions for a SCO or FCO...
                // WriteContext - write method param 1
                writeInstructions.append( InstructionConstants.ALOAD_1 );
                // this - for getfield
                writeInstructions.append( InstructionConstants.ALOAD_0 );
                // getfield value - write method param 2
                writeInstructions.append( factory.createGetField(className, fieldName, fieldType) );
                // this - write method param 3
                writeInstructions.append( InstructionConstants.ALOAD_0 );
                // Invoke writeObject method.
                writeInstructions.append( factory.createInvoke(sObjectSerializerClassName, "writeObject", Type.EnerJID, 
                                        sWriteObjectArgs, Constants.INVOKESTATIC) );
            }
        }

        // Invoke enerjPostStore if it exists
        if (hasPostStore) {
            // See comments on call to enerjPreStore for reason why INVOKESPECIAL is used.
            writeInstructions.append( InstructionConstants.ALOAD_0 );
            writeInstructions.append( factory.createInvoke(className, sPostStoreMethodName, Type.EnerJID, 
                                    Type.NO_ARGS, Constants.INVOKESPECIAL) );
        }
        
        // Invoke enerjPostLoad if it exists
        if (hasPostLoad) {
            // See comments on call to enerjPreStore for reason why INVOKESPECIAL is used.
            readInstructions.append( InstructionConstants.ALOAD_0 );
            readInstructions.append( factory.createInvoke(className, sPostLoadMethodName, Type.EnerJID, 
                                    Type.NO_ARGS, Constants.INVOKESPECIAL) );
        }
        
        InstructionHandle readStreamEnd = readInstructions.append( InstructionConstants.RETURN );
        InstructionHandle writeStreamEnd = writeInstructions.append( InstructionConstants.RETURN );

        // Add "throws java.io.IOException" to each method
        int exceptionsIdx = constantPoolGen.addUtf8("Exceptions");
        int[] exceptionsIdxTable = new int[] { constantPoolGen.addClass("java.io.IOException") };
        // Attribute length in bytes is 4 = 2 bytes for number of exceptions + 2 bytes for one index to an exception.
        readMethodGen.addAttribute(  new ExceptionTable(exceptionsIdx, 4, exceptionsIdxTable, constantPoolGen.getConstantPool()) );
        writeMethodGen.addAttribute(  new ExceptionTable(exceptionsIdx, 4, exceptionsIdxTable, constantPoolGen.getConstantPool()) );

        // Add local variable 2 to attributes
        readMethodGen.addLocalVariable("stream", sDataInputType, 2, readStreamStart.getNext(), readStreamEnd);
        writeMethodGen.addLocalVariable("stream", sDataOutputType, 2, writeStreamStart.getNext(), writeStreamEnd);

        addMethod(aClassGen, readMethodGen, readInstructions);
        readInstructions = null;
        
        addMethod(aClassGen, writeMethodGen, writeInstructions);
        writeInstructions = null;
    }
   
    //----------------------------------------------------------------------
    /**
     * Generate the enerj_Hollow method.
     *
     * @param aClassGen the ClassGen representing the class.
     * @param someFields a list of the persistent fields for this class (not including
     *  super-class fields).
     * @param isTopLevelPersistable true if this is a top-level persistable class.
     * @param hasPreHollow true if the enerjPreHollow method exists.
     *
     * @throws Exception in the event of an error.
     */
-    private void emitHollow(ClassGen aClassGen, ArrayList someFields, boolean isTopLevelPersistable,
        boolean hasPreHollow) throws Exception
    {
        String className = aClassGen.getClassName();
        String superClassName = aClassGen.getSuperclassName();
        ConstantPoolGen constantPoolGen = aClassGen.getConstantPool();
        InstructionFactory factory = new InstructionFactory(constantPoolGen);

        InstructionList instructions = new InstructionList();
        MethodGen methodGen = new MethodGen(
            Constants.ACC_PUBLIC,
            Type.EnerJID, Type.NO_ARGS, null,
            "enerj_Hollow", className, instructions, constantPoolGen);

        // Invoke enerjPreHollow if it exists
        if (hasPreHollow) {
            // See comments on call to enerjPreStore for reason why INVOKESPECIAL is used.
            instructions.append( InstructionConstants.ALOAD_0 );
            instructions.append( factory.createInvoke(className, sPreHollowMethodName, Type.EnerJID, 
                                    Type.NO_ARGS, Constants.INVOKESPECIAL) );
        }
        
        if (!isTopLevelPersistable) {
            // Call super read/write if not a top-level persistable
            instructions.append( InstructionConstants.ALOAD_0 );
            instructions.append( factory.createInvoke(superClassName, "enerj_Hollow", Type.EnerJID, 
                                    Type.NO_ARGS, Constants.INVOKESPECIAL) );
        }

        Iterator fields = someFields.iterator();
        while (fields.hasNext()) {
            Field field = (Field)fields.next();
            String fieldName = field.getName();
            String signature = field.getSignature();
            Type fieldType = Type.getType(signature);

            // This will return null if the type is not a primitive.
            if (!mMetaData.isPrimitive(signature)) {
               // this
                instructions.append( InstructionConstants.ALOAD_0 );
                // null
                instructions.append( InstructionConstants.ACONST_NULL );
                // Store the value
                instructions.append( factory.createPutField(className, fieldName, fieldType) );
            }
        }

        instructions.append( InstructionConstants.ALOAD_0 );
        instructions.append( factory.createInvoke(sPersistableHelperClassName, "completeHollow", Type.EnerJID, 
            sPersistableArg, Constants.INVOKESTATIC) );

        instructions.append( InstructionConstants.RETURN );
        addMethod(aClassGen, methodGen, instructions);
    }
   
    //----------------------------------------------------------------------
    /**
     * Generate class Id.<p>
     *
     * Note: In a test on 11,043 classes, this algorithm produced zero duplicates.
     *
     * @param someBytesCodes the unenhanced bytecodes of the class.
     *
     * @return a class Id that does not conflict with the system class Id range
     *  of [ObjectServer.NULL_CID..ObjectServer.LAST_SYSTEM_CID).
     *
     * @throws Exception if an error occurs (e.g., java.security.NoSuchAlgorithmException).
     */
-    private long generateClassId(byte[] someByteCodes) throws Exception 
    {
        java.security.MessageDigest sha1Digest = java.security.MessageDigest.getInstance("SHA-1");
        byte[] sha1 = sha1Digest.digest(someByteCodes);
        long cid =   (long)(sha1[0] & 0xff)         |
                    ((long)(sha1[1] & 0xff) <<  8) |
                    ((long)(sha1[2] & 0xff) << 16) |
                    ((long)(sha1[3] & 0xff) << 24) |
                    ((long)(sha1[4] & 0xff) << 32) |
                    ((long)(sha1[5] & 0xff) << 40) |
                    ((long)(sha1[6] & 0xff) << 48) |
                    ((long)(sha1[7] & 0xff) << 56);

        if (cid >= ObjectServer.NULL_CID && cid <= ObjectServer.LAST_SYSTEM_CID) {
            // Shift it up to make it a valid user CID.
            cid += ObjectServer.LAST_SYSTEM_CID;
        }
        
        return cid;
    }
}
